{
  "fentree": {
    "prefix": "fentree",
    "body": [
      "template <class T> struct FenTree {",
      "  // @attributes",
      "  int n;",
      "  vector<T> g, f;",
      " ",
      "  // @constructors",
      "  FenTree(int n = 0) : n(n) {",
      "    g = vector(n + 1, T());",
      "    f = vector(n + 1, T());",
      "  }",
      " ",
      "  FenTree(const vector<T> &g) : n(g.size() - 1) {",
      "    f = this->g = g;",
      "    rpt(i, 1, n + 1) {",
      "      if (int j = i + (i & -i); j <= n) {",
      "        f[j] += f[i];",
      "      }",
      "    }",
      "  }",
      " ",
      "  // @use_cases",
      "  void update(int i, T val) {",
      "    for (; i <= n; i += i & -i) {",
      "      f[i] += val;",
      "    }",
      "  }",
      " ",
      "  T query(int r) {",
      "    T res = T();",
      "    while (r > 0) {",
      "      res += f[r];",
      "      r -= r & -r;",
      "    }",
      "    return res;",
      "  }",
      " ",
      "  T query(int l, int r) {",
      "    T res = T();",
      "    while (r >= l) {",
      "      int m = r - (r & -r);",
      "      if (m >= l - 1) {",
      "        res += f[r];",
      "        r = m;",
      "      } else {",
      "        res += g[r--];",
      "      }",
      "    }",
      "    return res;",
      "  }",
      " ",
      "  int upper_bound(T val) {",
      "    int h = __lg(n);",
      "    int i = 0;",
      "    tpr(k, h + 1, 0) {",
      "      int j = i + (1 << k);",
      "      if (j > n)",
      "        continue;",
      "      if (val >= f[j]) {",
      "        val -= f[i = j];",
      "      }",
      "    }",
      "    return i + 1;",
      "  }",
      " ",
      "  int lower_bound(T val) { return upper_bound(val - 1); }",
      "};"
    ],
    "description": "Fenwick Tree for sum indexing"
  },
  "modint": {
    "prefix": "modint",
    "body": [
      "template <const int m> struct Mint {",
      "  int v;",
      "  static_assert(m > 0);",
      "",
      "  // @constructors",
      "  Mint(int64_t value = 0) : v(value % m) {",
      "    if (v < 0)",
      "      v += m;",
      "  }",
      "",
      "  // @increments",
      "  Mint &operator++() {",
      "    if (v++; v == m)",
      "      v = 0;",
      "    return *this;",
      "  }",
      "  Mint operator++(int) {",
      "    Mint result = *this;",
      "    ++*this;",
      "    return result;",
      "  }",
      "",
      "  // @decrements",
      "  Mint &operator--() {",
      "    if (v == 0)",
      "      v = m;",
      "    v--;",
      "    return *this;",
      "  }",
      "  Mint operator--(int) {",
      "    Mint result = *this;",
      "    --*this;",
      "    return result;",
      "  }",
      "",
      "  // @sign_operators",
      "  Mint operator+() const { return *this; }",
      "  Mint operator-() const { return Mint() - *this; }",
      "",
      "  // @inverse",
      "  Mint inv() const {",
      "    int a = 1, b = 0;",
      "    for (int x = v, y = m; x != 0;)",
      "      swap(a, b -= y / x * a), swap(x, y -= y / x * x);",
      "    return b + (b < 0) * m;",
      "  }",
      "",
      "  // @self_operators",
      "  Mint &operator+=(const Mint &other) {",
      "    if (v += other.v; v >= m)",
      "      v -= m;",
      "    return *this;",
      "  }",
      "  Mint &operator-=(const Mint &other) {",
      "    if (v -= other.v; v < 0)",
      "      v += m;",
      "    return *this;",
      "  }",
      "  Mint &operator*=(const Mint &other) {",
      "    v = ll(v) * other.v % m;",
      "    return *this;",
      "  }",
      "  Mint &operator/=(const Mint &other) {",
      "    *this *= other.inv();",
      "    return *this;",
      "  }",
      "",
      "  // @comparisons",
      "  friend bool operator==(const Mint &a, const Mint &b) { return a.v == b.v; }",
      "  friend bool operator!=(const Mint &a, const Mint &b) { return a.v != b.v; }",
      "",
      "  // @friend_operators",
      "  friend Mint operator+(const Mint &a, const Mint &b) { return Mint(a) += b; }",
      "  friend Mint operator-(const Mint &a, const Mint &b) { return Mint(a) -= b; }",
      "  friend Mint operator*(const Mint &a, const Mint &b) { return Mint(a) *= b; }",
      "  friend Mint operator/(const Mint &a, const Mint &b) { return Mint(a) /= b; }",
      "",
      "  // @streaming",
      "  friend istream &operator>>(istream &in, Mint &a) {",
      "    ll v;",
      "    in >> v;",
      "    return a = v, in;",
      "  }",
      "  friend ostream &operator<<(ostream &out, const Mint &a) {",
      "    out << a.v;",
      "    return out;",
      "  }",
      "  friend void __print(Mint &x) { cerr << x; }",
      "};"
    ],
    "description": "Modular int with fast arithmetic ops"
  },
  "matrix": {
    "prefix": "matrix",
    "body": [
      "template <class T> struct Matrix {",
      "  // @attributes",
      "  int n, m;",
      "  T **elts;",
      "  T *operator[](const int &r_idx) { return elts[r_idx]; }",
      "",
      "  // @utils",
      "  void init_elts() {",
      "    elts = new T *[n];",
      "    rpt(i, 0, n) elts[i] = new T[m]();",
      "  }",
      "  void copy_elts(T **elts) {",
      "    rpt(i, 0, n) copy(elts[i], elts[i] + m, this->elts[i]);",
      "  }",
      "  void erase_elts() {",
      "    rpt(i, 0, n) delete[] elts[i];",
      "    delete[] elts;",
      "  }",
      "",
      "  // @constructors",
      "  Matrix(int n, int m) : n(n), m(m) { init_elts(); }",
      "",
      "  Matrix(const initializer_list<initializer_list<T>> &elts) {",
      "    assert((n = elts.size()) != 0);",
      "    init_elts();",
      "",
      "    int i = 0;",
      "    for (auto &row : elts) {",
      "      m = row.size();",
      "      int j = 0;",
      "      for (auto &e : row) {",
      "        this->elts[i][j] = e;",
      "        j++;",
      "      }",
      "      i++;",
      "    }",
      "  }",
      "",
      "  Matrix(int n, int m, T **elts) : n(n), m(m), elts(elts) {}",
      "",
      "  Matrix(const Matrix &other) : Matrix(other.n, other.m) {",
      "    copy_elts(other.elts);",
      "  }",
      "",
      "  Matrix(Matrix &&other) noexcept : Matrix(other.n, other.m, other.elts) {",
      "    other.elts = nullptr;",
      "  }",
      "",
      "  // @destructor",
      "  ~Matrix() {",
      "    if (elts)",
      "      erase_elts();",
      "  }",
      "",
      "  // @assignments",
      "  Matrix &operator=(const Matrix &other) {",
      "    if (this != &other) {",
      "      erase_elts();",
      "      n = other.n;",
      "      m = other.m;",
      "      init_elts();",
      "      copy_elts(other.elts);",
      "    }",
      "    return *this;",
      "  }",
      "",
      "  Matrix &operator=(Matrix &&other) noexcept {",
      "    if (this != &other) {",
      "      erase_elts();",
      "      n = other.n;",
      "      m = other.m;",
      "      elts = other.elts;",
      "      other.elts = nullptr;",
      "    }",
      "    return *this;",
      "  }",
      "",
      "  // @operators",
      "  friend Matrix<T> operator*(const Matrix &a, const Matrix<T> &b) {",
      "    assert(a.m == b.n);",
      "    Matrix c(a.n, b.m);",
      "    rpt(i, 0, a.n) rpt(j, 0, b.m) rpt(k, 0, a.m) {",
      "      c[i][j] += a.elts[i][k] * b.elts[k][j];",
      "    }",
      "    return c;",
      "  }",
      "  Matrix<T> &operator*=(const Matrix &other) {",
      "    return *this = *this * other;",
      "  }",
      "",
      "  // @debug",
      "  friend void __print(Matrix x) {",
      "    cerr << \"Matrix({\\n\";",
      "    rpt(i, 0, x.n) {",
      "      cerr << \"  { \";",
      "      rpt(j, 0, x.m) {",
      "        __print(x.elts[i][j]);",
      "        if (j != x.m - 1)",
      "          cerr << \", \";",
      "      }",
      "      cerr << (i == x.n - 1 ? \" }\\n\" : \" },\\n\");",
      "    }",
      "    cerr << \"})\";",
      "  }",
      "};"
    ],
    "description": "2D implementation of Matrix"
  }
}